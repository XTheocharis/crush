// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: repo_map.sql

package db

import (
	"context"
)

const deleteRepoMapFileCache = `-- name: DeleteRepoMapFileCache :exec
DELETE FROM repo_map_file_cache
WHERE repo_key = ? AND rel_path = ?
`

type DeleteRepoMapFileCacheParams struct {
	RepoKey string `json:"repo_key"`
	RelPath string `json:"rel_path"`
}

func (q *Queries) DeleteRepoMapFileCache(ctx context.Context, arg DeleteRepoMapFileCacheParams) error {
	_, err := q.exec(ctx, q.deleteRepoMapFileCacheStmt, deleteRepoMapFileCache, arg.RepoKey, arg.RelPath)
	return err
}

const deleteRepoMapTagsByPath = `-- name: DeleteRepoMapTagsByPath :exec
DELETE FROM repo_map_tags
WHERE repo_key = ? AND rel_path = ?
`

type DeleteRepoMapTagsByPathParams struct {
	RepoKey string `json:"repo_key"`
	RelPath string `json:"rel_path"`
}

func (q *Queries) DeleteRepoMapTagsByPath(ctx context.Context, arg DeleteRepoMapTagsByPathParams) error {
	_, err := q.exec(ctx, q.deleteRepoMapTagsByPathStmt, deleteRepoMapTagsByPath, arg.RepoKey, arg.RelPath)
	return err
}

const deleteSessionRankings = `-- name: DeleteSessionRankings :exec
DELETE FROM repo_map_session_rankings
WHERE repo_key = ? AND session_id = ?
`

type DeleteSessionRankingsParams struct {
	RepoKey   string `json:"repo_key"`
	SessionID string `json:"session_id"`
}

func (q *Queries) DeleteSessionRankings(ctx context.Context, arg DeleteSessionRankingsParams) error {
	_, err := q.exec(ctx, q.deleteSessionRankingsStmt, deleteSessionRankings, arg.RepoKey, arg.SessionID)
	return err
}

const deleteSessionReadOnlyPaths = `-- name: DeleteSessionReadOnlyPaths :exec
DELETE FROM repo_map_session_read_only
WHERE repo_key = ? AND session_id = ?
`

type DeleteSessionReadOnlyPathsParams struct {
	RepoKey   string `json:"repo_key"`
	SessionID string `json:"session_id"`
}

func (q *Queries) DeleteSessionReadOnlyPaths(ctx context.Context, arg DeleteSessionReadOnlyPathsParams) error {
	_, err := q.exec(ctx, q.deleteSessionReadOnlyPathsStmt, deleteSessionReadOnlyPaths, arg.RepoKey, arg.SessionID)
	return err
}

const getRepoMapFileCache = `-- name: GetRepoMapFileCache :many
SELECT repo_key, rel_path, mtime, language, tag_count
FROM repo_map_file_cache
WHERE repo_key = ?
`

func (q *Queries) GetRepoMapFileCache(ctx context.Context, repoKey string) ([]RepoMapFileCache, error) {
	rows, err := q.query(ctx, q.getRepoMapFileCacheStmt, getRepoMapFileCache, repoKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RepoMapFileCache{}
	for rows.Next() {
		var i RepoMapFileCache
		if err := rows.Scan(
			&i.RepoKey,
			&i.RelPath,
			&i.Mtime,
			&i.Language,
			&i.TagCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRepoMapFileCacheByPath = `-- name: GetRepoMapFileCacheByPath :one
SELECT repo_key, rel_path, mtime, language, tag_count
FROM repo_map_file_cache
WHERE repo_key = ? AND rel_path = ?
`

type GetRepoMapFileCacheByPathParams struct {
	RepoKey string `json:"repo_key"`
	RelPath string `json:"rel_path"`
}

func (q *Queries) GetRepoMapFileCacheByPath(ctx context.Context, arg GetRepoMapFileCacheByPathParams) (RepoMapFileCache, error) {
	row := q.queryRow(ctx, q.getRepoMapFileCacheByPathStmt, getRepoMapFileCacheByPath, arg.RepoKey, arg.RelPath)
	var i RepoMapFileCache
	err := row.Scan(
		&i.RepoKey,
		&i.RelPath,
		&i.Mtime,
		&i.Language,
		&i.TagCount,
	)
	return i, err
}

const insertRepoMapTag = `-- name: InsertRepoMapTag :exec
INSERT INTO repo_map_tags (repo_key, rel_path, name, kind, node_type, line, language)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type InsertRepoMapTagParams struct {
	RepoKey  string `json:"repo_key"`
	RelPath  string `json:"rel_path"`
	Name     string `json:"name"`
	Kind     string `json:"kind"`
	NodeType string `json:"node_type"`
	Line     int64  `json:"line"`
	Language string `json:"language"`
}

func (q *Queries) InsertRepoMapTag(ctx context.Context, arg InsertRepoMapTagParams) error {
	_, err := q.exec(ctx, q.insertRepoMapTagStmt, insertRepoMapTag,
		arg.RepoKey,
		arg.RelPath,
		arg.Name,
		arg.Kind,
		arg.NodeType,
		arg.Line,
		arg.Language,
	)
	return err
}

const listRepoMapDefsByName = `-- name: ListRepoMapDefsByName :many
SELECT repo_key, rel_path, name, node_type, line, language
FROM repo_map_tags
WHERE repo_key = ? AND kind = 'def' AND name = ?
`

type ListRepoMapDefsByNameParams struct {
	RepoKey string `json:"repo_key"`
	Name    string `json:"name"`
}

type ListRepoMapDefsByNameRow struct {
	RepoKey  string `json:"repo_key"`
	RelPath  string `json:"rel_path"`
	Name     string `json:"name"`
	NodeType string `json:"node_type"`
	Line     int64  `json:"line"`
	Language string `json:"language"`
}

func (q *Queries) ListRepoMapDefsByName(ctx context.Context, arg ListRepoMapDefsByNameParams) ([]ListRepoMapDefsByNameRow, error) {
	rows, err := q.query(ctx, q.listRepoMapDefsByNameStmt, listRepoMapDefsByName, arg.RepoKey, arg.Name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRepoMapDefsByNameRow{}
	for rows.Next() {
		var i ListRepoMapDefsByNameRow
		if err := rows.Scan(
			&i.RepoKey,
			&i.RelPath,
			&i.Name,
			&i.NodeType,
			&i.Line,
			&i.Language,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRepoMapTags = `-- name: ListRepoMapTags :many
SELECT repo_key, rel_path, name, kind, node_type, line, language
FROM repo_map_tags
WHERE repo_key = ?
`

type ListRepoMapTagsRow struct {
	RepoKey  string `json:"repo_key"`
	RelPath  string `json:"rel_path"`
	Name     string `json:"name"`
	Kind     string `json:"kind"`
	NodeType string `json:"node_type"`
	Line     int64  `json:"line"`
	Language string `json:"language"`
}

func (q *Queries) ListRepoMapTags(ctx context.Context, repoKey string) ([]ListRepoMapTagsRow, error) {
	rows, err := q.query(ctx, q.listRepoMapTagsStmt, listRepoMapTags, repoKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRepoMapTagsRow{}
	for rows.Next() {
		var i ListRepoMapTagsRow
		if err := rows.Scan(
			&i.RepoKey,
			&i.RelPath,
			&i.Name,
			&i.Kind,
			&i.NodeType,
			&i.Line,
			&i.Language,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessionRankings = `-- name: ListSessionRankings :many
SELECT repo_key, session_id, rel_path, rank
FROM repo_map_session_rankings
WHERE repo_key = ? AND session_id = ?
ORDER BY rank DESC
`

type ListSessionRankingsParams struct {
	RepoKey   string `json:"repo_key"`
	SessionID string `json:"session_id"`
}

func (q *Queries) ListSessionRankings(ctx context.Context, arg ListSessionRankingsParams) ([]RepoMapSessionRanking, error) {
	rows, err := q.query(ctx, q.listSessionRankingsStmt, listSessionRankings, arg.RepoKey, arg.SessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RepoMapSessionRanking{}
	for rows.Next() {
		var i RepoMapSessionRanking
		if err := rows.Scan(
			&i.RepoKey,
			&i.SessionID,
			&i.RelPath,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessionReadOnlyPaths = `-- name: ListSessionReadOnlyPaths :many
SELECT rel_path
FROM repo_map_session_read_only
WHERE repo_key = ? AND session_id = ?
ORDER BY rel_path
`

type ListSessionReadOnlyPathsParams struct {
	RepoKey   string `json:"repo_key"`
	SessionID string `json:"session_id"`
}

func (q *Queries) ListSessionReadOnlyPaths(ctx context.Context, arg ListSessionReadOnlyPathsParams) ([]string, error) {
	rows, err := q.query(ctx, q.listSessionReadOnlyPathsStmt, listSessionReadOnlyPaths, arg.RepoKey, arg.SessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var rel_path string
		if err := rows.Scan(&rel_path); err != nil {
			return nil, err
		}
		items = append(items, rel_path)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertRepoMapFileCache = `-- name: UpsertRepoMapFileCache :exec
INSERT INTO repo_map_file_cache (repo_key, rel_path, mtime, language, tag_count)
VALUES (?, ?, ?, ?, ?)
ON CONFLICT(repo_key, rel_path) DO UPDATE SET mtime = excluded.mtime, language = excluded.language, tag_count = excluded.tag_count
`

type UpsertRepoMapFileCacheParams struct {
	RepoKey  string `json:"repo_key"`
	RelPath  string `json:"rel_path"`
	Mtime    int64  `json:"mtime"`
	Language string `json:"language"`
	TagCount int64  `json:"tag_count"`
}

func (q *Queries) UpsertRepoMapFileCache(ctx context.Context, arg UpsertRepoMapFileCacheParams) error {
	_, err := q.exec(ctx, q.upsertRepoMapFileCacheStmt, upsertRepoMapFileCache,
		arg.RepoKey,
		arg.RelPath,
		arg.Mtime,
		arg.Language,
		arg.TagCount,
	)
	return err
}

const upsertSessionRanking = `-- name: UpsertSessionRanking :exec
INSERT INTO repo_map_session_rankings (repo_key, session_id, rel_path, rank)
VALUES (?, ?, ?, ?)
ON CONFLICT(repo_key, session_id, rel_path) DO UPDATE SET rank = excluded.rank
`

type UpsertSessionRankingParams struct {
	RepoKey   string  `json:"repo_key"`
	SessionID string  `json:"session_id"`
	RelPath   string  `json:"rel_path"`
	Rank      float64 `json:"rank"`
}

func (q *Queries) UpsertSessionRanking(ctx context.Context, arg UpsertSessionRankingParams) error {
	_, err := q.exec(ctx, q.upsertSessionRankingStmt, upsertSessionRanking,
		arg.RepoKey,
		arg.SessionID,
		arg.RelPath,
		arg.Rank,
	)
	return err
}

const upsertSessionReadOnlyPath = `-- name: UpsertSessionReadOnlyPath :exec
INSERT INTO repo_map_session_read_only (repo_key, session_id, rel_path)
VALUES (?, ?, ?)
ON CONFLICT(repo_key, session_id, rel_path) DO NOTHING
`

type UpsertSessionReadOnlyPathParams struct {
	RepoKey   string `json:"repo_key"`
	SessionID string `json:"session_id"`
	RelPath   string `json:"rel_path"`
}

func (q *Queries) UpsertSessionReadOnlyPath(ctx context.Context, arg UpsertSessionReadOnlyPathParams) error {
	_, err := q.exec(ctx, q.upsertSessionReadOnlyPathStmt, upsertSessionReadOnlyPath, arg.RepoKey, arg.SessionID, arg.RelPath)
	return err
}
