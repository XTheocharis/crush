// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: lcm.sql

package db

import (
	"context"
	"database/sql"
)

const clearSessionSummaryMessageID = `-- name: ClearSessionSummaryMessageID :exec
UPDATE sessions SET summary_message_id = NULL WHERE id = ?
`

func (q *Queries) ClearSessionSummaryMessageID(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.clearSessionSummaryMessageIDStmt, clearSessionSummaryMessageID, id)
	return err
}

const deleteAllLcmContextItems = `-- name: DeleteAllLcmContextItems :exec
DELETE FROM lcm_context_items WHERE session_id = ?
`

func (q *Queries) DeleteAllLcmContextItems(ctx context.Context, sessionID string) error {
	_, err := q.exec(ctx, q.deleteAllLcmContextItemsStmt, deleteAllLcmContextItems, sessionID)
	return err
}

const deleteLcmSummary = `-- name: DeleteLcmSummary :exec
DELETE FROM lcm_summaries WHERE summary_id = ?
`

func (q *Queries) DeleteLcmSummary(ctx context.Context, summaryID string) error {
	_, err := q.exec(ctx, q.deleteLcmSummaryStmt, deleteLcmSummary, summaryID)
	return err
}

const deleteLcmSummaryMessages = `-- name: DeleteLcmSummaryMessages :exec
DELETE FROM lcm_summary_messages WHERE summary_id = ?
`

func (q *Queries) DeleteLcmSummaryMessages(ctx context.Context, summaryID string) error {
	_, err := q.exec(ctx, q.deleteLcmSummaryMessagesStmt, deleteLcmSummaryMessages, summaryID)
	return err
}

const deleteLcmSummaryParents = `-- name: DeleteLcmSummaryParents :exec
DELETE FROM lcm_summary_parents WHERE summary_id = ?
`

func (q *Queries) DeleteLcmSummaryParents(ctx context.Context, summaryID string) error {
	_, err := q.exec(ctx, q.deleteLcmSummaryParentsStmt, deleteLcmSummaryParents, summaryID)
	return err
}

const getLcmContextTokenCount = `-- name: GetLcmContextTokenCount :one
SELECT COALESCE(SUM(token_count), 0) AS total FROM lcm_context_items WHERE session_id = ?
`

func (q *Queries) GetLcmContextTokenCount(ctx context.Context, sessionID string) (interface{}, error) {
	row := q.queryRow(ctx, q.getLcmContextTokenCountStmt, getLcmContextTokenCount, sessionID)
	var total interface{}
	err := row.Scan(&total)
	return total, err
}

const getLcmLargeFile = `-- name: GetLcmLargeFile :one
SELECT file_id, session_id, original_path, content, token_count, exploration_summary, explorer_used, created_at FROM lcm_large_files WHERE file_id = ?
`

func (q *Queries) GetLcmLargeFile(ctx context.Context, fileID string) (LcmLargeFile, error) {
	row := q.queryRow(ctx, q.getLcmLargeFileStmt, getLcmLargeFile, fileID)
	var i LcmLargeFile
	err := row.Scan(
		&i.FileID,
		&i.SessionID,
		&i.OriginalPath,
		&i.Content,
		&i.TokenCount,
		&i.ExplorationSummary,
		&i.ExplorerUsed,
		&i.CreatedAt,
	)
	return i, err
}

const getLcmSessionConfig = `-- name: GetLcmSessionConfig :one
SELECT session_id, model_name, model_ctx_max_tokens, ctx_cutoff_threshold, soft_threshold_tokens, hard_threshold_tokens, created_at, updated_at FROM lcm_session_config WHERE session_id = ?
`

func (q *Queries) GetLcmSessionConfig(ctx context.Context, sessionID string) (LcmSessionConfig, error) {
	row := q.queryRow(ctx, q.getLcmSessionConfigStmt, getLcmSessionConfig, sessionID)
	var i LcmSessionConfig
	err := row.Scan(
		&i.SessionID,
		&i.ModelName,
		&i.ModelCtxMaxTokens,
		&i.CtxCutoffThreshold,
		&i.SoftThresholdTokens,
		&i.HardThresholdTokens,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLcmSummary = `-- name: GetLcmSummary :one
SELECT summary_id, session_id, kind, content, token_count, file_ids, created_at FROM lcm_summaries WHERE summary_id = ?
`

func (q *Queries) GetLcmSummary(ctx context.Context, summaryID string) (LcmSummary, error) {
	row := q.queryRow(ctx, q.getLcmSummaryStmt, getLcmSummary, summaryID)
	var i LcmSummary
	err := row.Scan(
		&i.SummaryID,
		&i.SessionID,
		&i.Kind,
		&i.Content,
		&i.TokenCount,
		&i.FileIds,
		&i.CreatedAt,
	)
	return i, err
}

const insertLcmContextItem = `-- name: InsertLcmContextItem :exec
INSERT INTO lcm_context_items (session_id, position, item_type, message_id, summary_id, token_count)
VALUES (?, ?, ?, ?, ?, ?)
`

type InsertLcmContextItemParams struct {
	SessionID  string         `json:"session_id"`
	Position   int64          `json:"position"`
	ItemType   string         `json:"item_type"`
	MessageID  sql.NullString `json:"message_id"`
	SummaryID  sql.NullString `json:"summary_id"`
	TokenCount int64          `json:"token_count"`
}

// LCM Context Items
func (q *Queries) InsertLcmContextItem(ctx context.Context, arg InsertLcmContextItemParams) error {
	_, err := q.exec(ctx, q.insertLcmContextItemStmt, insertLcmContextItem,
		arg.SessionID,
		arg.Position,
		arg.ItemType,
		arg.MessageID,
		arg.SummaryID,
		arg.TokenCount,
	)
	return err
}

const insertLcmLargeFile = `-- name: InsertLcmLargeFile :exec
INSERT INTO lcm_large_files (file_id, session_id, original_path, content, token_count, exploration_summary, explorer_used)
VALUES (?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(file_id) DO NOTHING
`

type InsertLcmLargeFileParams struct {
	FileID             string         `json:"file_id"`
	SessionID          string         `json:"session_id"`
	OriginalPath       string         `json:"original_path"`
	Content            sql.NullString `json:"content"`
	TokenCount         int64          `json:"token_count"`
	ExplorationSummary sql.NullString `json:"exploration_summary"`
	ExplorerUsed       sql.NullString `json:"explorer_used"`
}

// LCM Large Files
func (q *Queries) InsertLcmLargeFile(ctx context.Context, arg InsertLcmLargeFileParams) error {
	_, err := q.exec(ctx, q.insertLcmLargeFileStmt, insertLcmLargeFile,
		arg.FileID,
		arg.SessionID,
		arg.OriginalPath,
		arg.Content,
		arg.TokenCount,
		arg.ExplorationSummary,
		arg.ExplorerUsed,
	)
	return err
}

const insertLcmMapItem = `-- name: InsertLcmMapItem :exec
INSERT INTO lcm_map_items (item_id, run_id, input_json) VALUES (?, ?, ?)
`

type InsertLcmMapItemParams struct {
	ItemID    string `json:"item_id"`
	RunID     string `json:"run_id"`
	InputJson string `json:"input_json"`
}

// LCM Map Items
func (q *Queries) InsertLcmMapItem(ctx context.Context, arg InsertLcmMapItemParams) error {
	_, err := q.exec(ctx, q.insertLcmMapItemStmt, insertLcmMapItem, arg.ItemID, arg.RunID, arg.InputJson)
	return err
}

const insertLcmMapRun = `-- name: InsertLcmMapRun :exec
INSERT INTO lcm_map_runs (run_id, session_id, input_path, output_path, schema_json)
VALUES (?, ?, ?, ?, ?)
`

type InsertLcmMapRunParams struct {
	RunID      string `json:"run_id"`
	SessionID  string `json:"session_id"`
	InputPath  string `json:"input_path"`
	OutputPath string `json:"output_path"`
	SchemaJson string `json:"schema_json"`
}

// LCM Map Runs
func (q *Queries) InsertLcmMapRun(ctx context.Context, arg InsertLcmMapRunParams) error {
	_, err := q.exec(ctx, q.insertLcmMapRunStmt, insertLcmMapRun,
		arg.RunID,
		arg.SessionID,
		arg.InputPath,
		arg.OutputPath,
		arg.SchemaJson,
	)
	return err
}

const insertLcmSummary = `-- name: InsertLcmSummary :exec
INSERT INTO lcm_summaries (summary_id, session_id, kind, content, token_count, file_ids)
VALUES (?, ?, ?, ?, ?, ?)
`

type InsertLcmSummaryParams struct {
	SummaryID  string `json:"summary_id"`
	SessionID  string `json:"session_id"`
	Kind       string `json:"kind"`
	Content    string `json:"content"`
	TokenCount int64  `json:"token_count"`
	FileIds    string `json:"file_ids"`
}

// LCM Summaries
func (q *Queries) InsertLcmSummary(ctx context.Context, arg InsertLcmSummaryParams) error {
	_, err := q.exec(ctx, q.insertLcmSummaryStmt, insertLcmSummary,
		arg.SummaryID,
		arg.SessionID,
		arg.Kind,
		arg.Content,
		arg.TokenCount,
		arg.FileIds,
	)
	return err
}

const insertLcmSummaryMessage = `-- name: InsertLcmSummaryMessage :exec
INSERT INTO lcm_summary_messages (summary_id, message_id, ord)
VALUES (?, ?, ?)
`

type InsertLcmSummaryMessageParams struct {
	SummaryID string `json:"summary_id"`
	MessageID string `json:"message_id"`
	Ord       int64  `json:"ord"`
}

// LCM Summary Messages
func (q *Queries) InsertLcmSummaryMessage(ctx context.Context, arg InsertLcmSummaryMessageParams) error {
	_, err := q.exec(ctx, q.insertLcmSummaryMessageStmt, insertLcmSummaryMessage, arg.SummaryID, arg.MessageID, arg.Ord)
	return err
}

const insertLcmSummaryParent = `-- name: InsertLcmSummaryParent :exec
INSERT INTO lcm_summary_parents (summary_id, parent_summary_id, ord)
VALUES (?, ?, ?)
`

type InsertLcmSummaryParentParams struct {
	SummaryID       string `json:"summary_id"`
	ParentSummaryID string `json:"parent_summary_id"`
	Ord             int64  `json:"ord"`
}

// LCM Summary Parents
func (q *Queries) InsertLcmSummaryParent(ctx context.Context, arg InsertLcmSummaryParentParams) error {
	_, err := q.exec(ctx, q.insertLcmSummaryParentStmt, insertLcmSummaryParent, arg.SummaryID, arg.ParentSummaryID, arg.Ord)
	return err
}

const listLcmContextItems = `-- name: ListLcmContextItems :many
SELECT session_id, position, item_type, message_id, summary_id, token_count FROM lcm_context_items WHERE session_id = ? ORDER BY position ASC
`

func (q *Queries) ListLcmContextItems(ctx context.Context, sessionID string) ([]LcmContextItem, error) {
	rows, err := q.query(ctx, q.listLcmContextItemsStmt, listLcmContextItems, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LcmContextItem{}
	for rows.Next() {
		var i LcmContextItem
		if err := rows.Scan(
			&i.SessionID,
			&i.Position,
			&i.ItemType,
			&i.MessageID,
			&i.SummaryID,
			&i.TokenCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLcmLargeFilesBySession = `-- name: ListLcmLargeFilesBySession :many
SELECT file_id, session_id, original_path, content, token_count, exploration_summary, explorer_used, created_at FROM lcm_large_files WHERE session_id = ? ORDER BY created_at ASC
`

func (q *Queries) ListLcmLargeFilesBySession(ctx context.Context, sessionID string) ([]LcmLargeFile, error) {
	rows, err := q.query(ctx, q.listLcmLargeFilesBySessionStmt, listLcmLargeFilesBySession, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LcmLargeFile{}
	for rows.Next() {
		var i LcmLargeFile
		if err := rows.Scan(
			&i.FileID,
			&i.SessionID,
			&i.OriginalPath,
			&i.Content,
			&i.TokenCount,
			&i.ExplorationSummary,
			&i.ExplorerUsed,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLcmSummariesBySession = `-- name: ListLcmSummariesBySession :many
SELECT summary_id, session_id, kind, content, token_count, file_ids, created_at FROM lcm_summaries WHERE session_id = ? ORDER BY created_at ASC
`

func (q *Queries) ListLcmSummariesBySession(ctx context.Context, sessionID string) ([]LcmSummary, error) {
	rows, err := q.query(ctx, q.listLcmSummariesBySessionStmt, listLcmSummariesBySession, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LcmSummary{}
	for rows.Next() {
		var i LcmSummary
		if err := rows.Scan(
			&i.SummaryID,
			&i.SessionID,
			&i.Kind,
			&i.Content,
			&i.TokenCount,
			&i.FileIds,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLcmSummaryMessages = `-- name: ListLcmSummaryMessages :many
SELECT summary_id, message_id, ord FROM lcm_summary_messages WHERE summary_id = ? ORDER BY ord ASC
`

func (q *Queries) ListLcmSummaryMessages(ctx context.Context, summaryID string) ([]LcmSummaryMessage, error) {
	rows, err := q.query(ctx, q.listLcmSummaryMessagesStmt, listLcmSummaryMessages, summaryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LcmSummaryMessage{}
	for rows.Next() {
		var i LcmSummaryMessage
		if err := rows.Scan(&i.SummaryID, &i.MessageID, &i.Ord); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLcmSummaryParents = `-- name: ListLcmSummaryParents :many
SELECT summary_id, parent_summary_id, ord FROM lcm_summary_parents WHERE summary_id = ? ORDER BY ord ASC
`

func (q *Queries) ListLcmSummaryParents(ctx context.Context, summaryID string) ([]LcmSummaryParent, error) {
	rows, err := q.query(ctx, q.listLcmSummaryParentsStmt, listLcmSummaryParents, summaryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LcmSummaryParent{}
	for rows.Next() {
		var i LcmSummaryParent
		if err := rows.Scan(&i.SummaryID, &i.ParentSummaryID, &i.Ord); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessagesBySessionSeq = `-- name: ListMessagesBySessionSeq :many
SELECT id, session_id, role, parts, model, created_at, updated_at, finished_at, provider, is_summary_message, seq, token_count FROM messages WHERE session_id = ? ORDER BY seq ASC
`

func (q *Queries) ListMessagesBySessionSeq(ctx context.Context, sessionID string) ([]Message, error) {
	rows, err := q.query(ctx, q.listMessagesBySessionSeqStmt, listMessagesBySessionSeq, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.Role,
			&i.Parts,
			&i.Model,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FinishedAt,
			&i.Provider,
			&i.IsSummaryMessage,
			&i.Seq,
			&i.TokenCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessagesInSeqRange = `-- name: ListMessagesInSeqRange :many
SELECT id, session_id, role, parts, model, created_at, updated_at, finished_at, provider, is_summary_message, seq, token_count FROM messages WHERE session_id = ? AND seq >= ? AND seq <= ? ORDER BY seq ASC
`

type ListMessagesInSeqRangeParams struct {
	SessionID string `json:"session_id"`
	Seq       int64  `json:"seq"`
	Seq_2     int64  `json:"seq_2"`
}

func (q *Queries) ListMessagesInSeqRange(ctx context.Context, arg ListMessagesInSeqRangeParams) ([]Message, error) {
	rows, err := q.query(ctx, q.listMessagesInSeqRangeStmt, listMessagesInSeqRange, arg.SessionID, arg.Seq, arg.Seq_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.Role,
			&i.Parts,
			&i.Model,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FinishedAt,
			&i.Provider,
			&i.IsSummaryMessage,
			&i.Seq,
			&i.TokenCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchLcmSummaries = `-- name: SearchLcmSummaries :many
SELECT summary_id, kind FROM lcm_summaries
WHERE rowid IN (
    SELECT lcm_summaries_fts.rowid FROM lcm_summaries_fts WHERE lcm_summaries_fts.content MATCH ?
)
AND session_id = ?
`

type SearchLcmSummariesParams struct {
	Content   string `json:"content"`
	SessionID string `json:"session_id"`
}

type SearchLcmSummariesRow struct {
	SummaryID string `json:"summary_id"`
	Kind      string `json:"kind"`
}

func (q *Queries) SearchLcmSummaries(ctx context.Context, arg SearchLcmSummariesParams) ([]SearchLcmSummariesRow, error) {
	rows, err := q.query(ctx, q.searchLcmSummariesStmt, searchLcmSummaries, arg.Content, arg.SessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchLcmSummariesRow{}
	for rows.Next() {
		var i SearchLcmSummariesRow
		if err := rows.Scan(&i.SummaryID, &i.Kind); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLcmLargeFileExploration = `-- name: UpdateLcmLargeFileExploration :exec
UPDATE lcm_large_files SET exploration_summary = ?, explorer_used = ? WHERE file_id = ?
`

type UpdateLcmLargeFileExplorationParams struct {
	ExplorationSummary sql.NullString `json:"exploration_summary"`
	ExplorerUsed       sql.NullString `json:"explorer_used"`
	FileID             string         `json:"file_id"`
}

func (q *Queries) UpdateLcmLargeFileExploration(ctx context.Context, arg UpdateLcmLargeFileExplorationParams) error {
	_, err := q.exec(ctx, q.updateLcmLargeFileExplorationStmt, updateLcmLargeFileExploration, arg.ExplorationSummary, arg.ExplorerUsed, arg.FileID)
	return err
}

const updateLcmMapItem = `-- name: UpdateLcmMapItem :exec
UPDATE lcm_map_items SET status = ?, output_json = ?, error_msg = ?, updated_at = strftime('%s', 'now') WHERE item_id = ?
`

type UpdateLcmMapItemParams struct {
	Status     string         `json:"status"`
	OutputJson sql.NullString `json:"output_json"`
	ErrorMsg   sql.NullString `json:"error_msg"`
	ItemID     string         `json:"item_id"`
}

func (q *Queries) UpdateLcmMapItem(ctx context.Context, arg UpdateLcmMapItemParams) error {
	_, err := q.exec(ctx, q.updateLcmMapItemStmt, updateLcmMapItem,
		arg.Status,
		arg.OutputJson,
		arg.ErrorMsg,
		arg.ItemID,
	)
	return err
}

const updateLcmMapRunStatus = `-- name: UpdateLcmMapRunStatus :exec
UPDATE lcm_map_runs SET status = ?, updated_at = strftime('%s', 'now') WHERE run_id = ?
`

type UpdateLcmMapRunStatusParams struct {
	Status string `json:"status"`
	RunID  string `json:"run_id"`
}

func (q *Queries) UpdateLcmMapRunStatus(ctx context.Context, arg UpdateLcmMapRunStatusParams) error {
	_, err := q.exec(ctx, q.updateLcmMapRunStatusStmt, updateLcmMapRunStatus, arg.Status, arg.RunID)
	return err
}

const updateLcmSessionConfig = `-- name: UpdateLcmSessionConfig :exec
UPDATE lcm_session_config SET
    model_name = ?,
    model_ctx_max_tokens = ?,
    ctx_cutoff_threshold = ?,
    soft_threshold_tokens = ?,
    hard_threshold_tokens = ?,
    updated_at = strftime('%s', 'now')
WHERE session_id = ?
`

type UpdateLcmSessionConfigParams struct {
	ModelName           string  `json:"model_name"`
	ModelCtxMaxTokens   int64   `json:"model_ctx_max_tokens"`
	CtxCutoffThreshold  float64 `json:"ctx_cutoff_threshold"`
	SoftThresholdTokens int64   `json:"soft_threshold_tokens"`
	HardThresholdTokens int64   `json:"hard_threshold_tokens"`
	SessionID           string  `json:"session_id"`
}

func (q *Queries) UpdateLcmSessionConfig(ctx context.Context, arg UpdateLcmSessionConfigParams) error {
	_, err := q.exec(ctx, q.updateLcmSessionConfigStmt, updateLcmSessionConfig,
		arg.ModelName,
		arg.ModelCtxMaxTokens,
		arg.CtxCutoffThreshold,
		arg.SoftThresholdTokens,
		arg.HardThresholdTokens,
		arg.SessionID,
	)
	return err
}

const updateMessageTokenCount = `-- name: UpdateMessageTokenCount :exec
UPDATE messages SET token_count = ? WHERE id = ?
`

type UpdateMessageTokenCountParams struct {
	TokenCount int64  `json:"token_count"`
	ID         string `json:"id"`
}

func (q *Queries) UpdateMessageTokenCount(ctx context.Context, arg UpdateMessageTokenCountParams) error {
	_, err := q.exec(ctx, q.updateMessageTokenCountStmt, updateMessageTokenCount, arg.TokenCount, arg.ID)
	return err
}

const upsertLcmSessionConfig = `-- name: UpsertLcmSessionConfig :exec
INSERT INTO lcm_session_config (session_id, model_name, model_ctx_max_tokens, ctx_cutoff_threshold, soft_threshold_tokens, hard_threshold_tokens)
VALUES (?, ?, ?, ?, ?, ?)
ON CONFLICT(session_id) DO NOTHING
`

type UpsertLcmSessionConfigParams struct {
	SessionID           string  `json:"session_id"`
	ModelName           string  `json:"model_name"`
	ModelCtxMaxTokens   int64   `json:"model_ctx_max_tokens"`
	CtxCutoffThreshold  float64 `json:"ctx_cutoff_threshold"`
	SoftThresholdTokens int64   `json:"soft_threshold_tokens"`
	HardThresholdTokens int64   `json:"hard_threshold_tokens"`
}

// LCM Session Config
func (q *Queries) UpsertLcmSessionConfig(ctx context.Context, arg UpsertLcmSessionConfigParams) error {
	_, err := q.exec(ctx, q.upsertLcmSessionConfigStmt, upsertLcmSessionConfig,
		arg.SessionID,
		arg.ModelName,
		arg.ModelCtxMaxTokens,
		arg.CtxCutoffThreshold,
		arg.SoftThresholdTokens,
		arg.HardThresholdTokens,
	)
	return err
}
