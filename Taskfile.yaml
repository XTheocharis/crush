# https://taskfile.dev

version: "3"

vars:
  VERSION:
    sh: git describe --long 2>/dev/null || echo ""
  RACE:
    sh: test -f race.log && echo "1" || echo ""

env:
  CGO_ENABLED: 1
  GOEXPERIMENT: greenteagc

tasks:
  lint:install:
    desc: Install golangci-lint
    cmds:
      - go install github.com/golangci/golangci-lint/v2/cmd/golangci-lint@latest
    env:
      GOTOOLCHAIN: go1.26.0

  lint:
    desc: Run base linters
    cmds:
      - task: lint:log
      - golangci-lint run --path-mode=abs --config=".golangci.yml" --timeout=5m
    env:
      GOEXPERIMENT: null

  lint:log:
    desc: Check that log messages start with capital letters
    cmds:
      - ./scripts/check_log_capitalization.sh

  lint:fix:
    desc: Run base linters and fix issues
    cmds:
      - golangci-lint run --path-mode=abs --config=".golangci.yml" --timeout=5m --fix
    env:
      GOEXPERIMENT: null

  build:
    desc: Run build
    vars:
      LDFLAGS: '{{if .VERSION}}-ldflags="-X github.com/charmbracelet/crush/internal/version.Version={{.VERSION}}"{{end}}'
    cmds:
      - "go build -v {{if .RACE}}-race{{end}} {{.LDFLAGS}} ."
    sources:
      - ./**/*.go
      - go.mod
    generates:
      - crush{{exeExt}}

  build:cgo:
    desc: Build with explicit CGO_ENABLED (requires CGO)
    vars:
      LDFLAGS: '{{if .VERSION}}-ldflags="-X github.com/charmbracelet/crush/internal/version.Version={{.VERSION}}"{{end}}'
    env:
      CGO_ENABLED: 1
    cmds:
      - "go build -v {{.LDFLAGS}} ."
    sources:
      - ./**/*.go
      - go.mod
    generates:
      - crush{{exeExt}}

  build:nocgo:
    desc: Build without CGO (non-signoff compatibility check)
    vars:
      LDFLAGS: '{{if .VERSION}}-ldflags="-X github.com/charmbracelet/crush/internal/version.Version={{.VERSION}}"{{end}}'
    env:
      CGO_ENABLED: 0
    cmds:
      - "go build -v {{.LDFLAGS}} ."
    sources:
      - ./**/*.go
      - go.mod
    generates:
      - crush{{exeExt}}

  build:all:
    desc: Regenerate all generated files and build
    cmds:
      - task: sqlc
      - task: hyper
      - task: schema
      - task: build

  run:
    desc: Run build
    cmds:
      - task: build
      - "./crush{{exeExt}} {{.CLI_ARGS}} {{if .RACE}}2>race.log{{end}}"

  run:catwalk:
    desc: Run build with local Catwalk
    env:
      CATWALK_URL: http://localhost:8080
    cmds:
      - task: build
      - ./crush{{exeExt}} {{.CLI_ARGS}}

  run:onboarding:
    desc: Run build with custom config to test onboarding
    env:
      CRUSH_GLOBAL_DATA: tmp/onboarding/data
      CRUSH_GLOBAL_CONFIG: tmp/onboarding/config
    cmds:
      - task: build
      - rm -rf tmp/onboarding
      - ./crush{exeExt} {{.CLI_ARGS}}

  test:
    desc: Run tests
    env:
      CGO_ENABLED: 1
    cmds:
      - go test -race -failfast ./... {{.CLI_ARGS}}

  test:cgo:
    desc: Run tests with explicit CGO_ENABLED (requires CGO)
    env:
      CGO_ENABLED: 1
    cmds:
      - go test -race -failfast ./... {{.CLI_ARGS}}

  test:nocgo:
    desc: Run tests without CGO (non-signoff compatibility check)
    env:
      CGO_ENABLED: 0
    cmds:
      - go test -failfast ./... {{.CLI_ARGS}}

  test:parity:
    desc: Run parity mode tests (parity_mode=true, requires CGO)
    env:
      CGO_ENABLED: 1
      PARITY_MODE: true
    cmds:
      - test "$CGO_ENABLED" = "1" || { echo "test:parity requires CGO_ENABLED=1"; exit 1; }
      - go test -race -failfast ./... -run Parity {{.CLI_ARGS}}

  parity:bundle:
    desc: Generate and validate local atomic parity sign-off bundle (requires CGO)
    env:
      CGO_ENABLED: 1
      PARITY_MODE: true
    cmds:
      - test "$CGO_ENABLED" = "1" || { echo "parity:bundle requires CGO_ENABLED=1"; exit 1; }
      - go test -failfast ./internal/repomap/... ./internal/lcm/explorer/... -run 'Conformance|Bundle|Manifest' -count=1 {{.CLI_ARGS}}

  test:exceed:
    desc: Run exceed mode tests (parity_mode=false, requires CGO)
    env:
      CGO_ENABLED: 1
      PARITY_MODE: false
    cmds:
      - test "$CGO_ENABLED" = "1" || { echo "test:exceed requires CGO_ENABLED=1"; exit 1; }
      - go test -race -failfast ./... -run Exceed {{.CLI_ARGS}}

  test:record:
    desc: Run tests and record all VCR cassettes again
    aliases: [record]
    cmds:
      - rm -r internal/agent/testdata
      - go test -v -count=1 -timeout=1h ./internal/agent

  fmt:
    desc: Run gofumpt
    cmds:
      - gofumpt -w .

  fmt:html:
    desc: Run prettier on HTML/CSS/JS files
    cmds:
      - prettier --write internal/cmd/stats/index.html internal/cmd/stats/index.css internal/cmd/stats/index.js

  modernize:
    desc: Run modernize
    cmds:
      - go run golang.org/x/tools/go/analysis/passes/modernize/cmd/modernize@latest -fix -test ./...

  dev:
    desc: Run with profiling enabled
    env:
      CRUSH_PROFILE: true
    cmds:
      - go run .

  install:
    desc: Install the application
    vars:
      LDFLAGS: '{{if .VERSION}}-ldflags="-X github.com/charmbracelet/crush/internal/version.Version={{.VERSION}}"{{end}}'
    cmds:
      - task: fetch-tags
      - go install {{.LDFLAGS}} -v .
    sources:
      - ./**/*.go
      - go.mod

  profile:cpu:
    desc: 10s CPU profile (interactive, requires running dev instance)
    cmds:
      - go tool pprof -http :6061 'http://localhost:6060/debug/pprof/profile?seconds=10'

  profile:heap:
    desc: Heap profile (interactive, requires running dev instance)
    cmds:
      - go tool pprof -http :6061 'http://localhost:6060/debug/pprof/heap'

  profile:allocs:
    desc: Allocations profile (interactive, requires running dev instance)
    cmds:
      - go tool pprof -http :6061 'http://localhost:6060/debug/pprof/allocs'

  profile:start:
    desc: Start crush with profiling in a detached tmux session
    cmds:
      - tmux new-session -d -s crush-profile 'CRUSH_PROFILE=true go run .'
      - echo "Waiting for pprof endpoint..."
      - 'until curl -sf http://localhost:6060/debug/pprof/ > /dev/null 2>&1; do sleep 0.5; done'
      - 'echo "Crush profiling session ready (tmux session: crush-profile)"'

  profile:stop:
    desc: Stop the crush profiling tmux session
    cmds:
      - tmux kill-session -t crush-profile

  profile:capture:
    desc: Capture CPU (10s), heap, and allocs profiles to ./profiles/
    cmds:
      - mkdir -p profiles
      - echo "Capturing CPU profile (10s)..."
      - curl -sf -o profiles/cpu.pprof 'http://localhost:6060/debug/pprof/profile?seconds=10'
      - echo "Capturing heap profile..."
      - curl -sf -o profiles/heap.pprof 'http://localhost:6060/debug/pprof/heap'
      - echo "Capturing allocs profile..."
      - curl -sf -o profiles/allocs.pprof 'http://localhost:6060/debug/pprof/allocs'
      - echo "Profiles saved to ./profiles/"

  profile:run:
    desc: Headless full profile run (start dev, capture all profiles, stop)
    cmds:
      - task: profile:start
      - task: profile:capture
      - task: profile:stop

  schema:
    desc: Generate JSON schema for configuration
    cmds:
      - go run main.go schema > schema.json
      - echo "Generated schema.json"
    generates:
      - schema.json

  sqlc:
    desc: Regenerate sqlc database layer
    cmds:
      - sqlc generate
    sources:
      - ./internal/db/sql/*.sql
      - ./internal/db/migrations/*.sql
      - ./sqlc.yaml
    generates:
      - ./internal/db/db.go
      - ./internal/db/models.go
      - ./internal/db/querier.go
      - ./internal/db/*.sql.go

  hyper:
    desc: Update Hyper embedded provider.json
    cmds:
      - go generate ./internal/agent/hyper/...
    generates:
      - ./internal/agent/hyper/provider.json

  release:
    desc: Create and push a new tag following semver
    vars:
      NEXT:
        sh: svu next --always || go run github.com/caarlos0/svu/v3@latest next --always
    prompt: "This will release {{.NEXT}}. Continue?"
    preconditions:
      - sh: '[ $(git symbolic-ref --short HEAD) = "main" ]'
        msg: Not on main branch
      - sh: "[ $(git status --porcelain=2 | wc -l) = 0 ]"
        msg: "Git is dirty"
      - sh: 'gh run list --workflow build.yml --commit $(git rev-parse HEAD) --status success --json conclusion -q ".[0].conclusion" | grep -q success'
        msg: "Test build for this commit failed or not present"
      - sh: 'gh run list --workflow snapshot.yml --commit $(git rev-parse HEAD) --status success --json conclusion -q ".[0].conclusion" | grep -q success'
        msg: "Snapshot build for this commit failed or not present"
    cmds:
      - task: fetch-tags
      - git commit --allow-empty -m "{{.NEXT}}"
      - git tag --annotate --sign -m "{{.NEXT}}" {{.NEXT}} {{.CLI_ARGS}}
      - echo "Pushing {{.NEXT}}..."
      - git push origin main --follow-tags

  fetch-tags:
    cmds:
      - git tag -d nightly || true
      - git fetch --tags

  deps:
    desc: Update Fantasy and Catwalk
    cmds:
      - go get charm.land/fantasy
      - go get charm.land/catwalk
      - go mod tidy

  tsaudit:
    desc: Run treesitter dependency check
    cmds:
      - go run ./internal/cmd/tsaudit check {{.CLI_ARGS}}

  tsaudit:update:
    desc: Update treesitter dependency files
    cmds:
      - go run ./internal/cmd/tsaudit update {{.CLI_ARGS}}

  tsaudit:verify:
    desc: Verify treesitter dependencies are up to date
    cmds:
      - go run ./internal/cmd/tsaudit verify {{.CLI_ARGS}}

  validate:ts:
    desc: Validate tree-sitter parser setup (requires CGO)
    env:
      CGO_ENABLED: 1
    cmds:
      - test "$CGO_ENABLED" = "1" || { echo "validate:ts requires CGO_ENABLED=1"; exit 1; }
      - go test -run TestTsParser -v ./internal/treesitter/
      - task: tsaudit

  validate:repomap:
    desc: Validate repo-map implementation (requires CGO)
    env:
      CGO_ENABLED: 1
    cmds:
      - test "$CGO_ENABLED" = "1" || { echo "validate:repomap requires CGO_ENABLED=1"; exit 1; }
      - go test -run TestRepoMap -race -v ./internal/repomap/
